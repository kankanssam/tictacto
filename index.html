<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>깐깐샘과 틱택토</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@400;700&display=swap" rel="stylesheet">
    
    <style>
        /* CSS 코드 시작 */
        :root {
            --bg-color: #f0f8ff; /* AliceBlue */
            --container-bg: #ffffff;
            --board-bg: #e6e6fa; /* Lavender */
            --cell-bg: #fafad2; /* LightGoldenRodYellow */
            --btn-bg: #add8e6; /* LightBlue */
            --btn-hover-bg: #87ceeb; /* SkyBlue */
            --btn-active-bg: #ffb6c1; /* LightPink */
            --text-color: #333;
            --x-color: #ff7f7f; /* Coral */
            --o-color: #7f7fff; /* RoyalBlue */
            --shadow-color: rgba(0, 0, 0, 0.1);
        }

        body {
            margin: 0;
            font-family: 'M PLUS Rounded 1c', sans-serif;
            display: flex;
            flex-direction: column; /* 푸터를 위해 flex-direction 변경 */
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: var(--bg-color);
            color: var(--text-color);
        }

        .game-container {
            background-color: var(--container-bg);
            padding: 2.5rem; /* 패딩도 약간 늘림 */
            border-radius: 15px;
            box-shadow: 0 10px 20px var(--shadow-color);
            text-align: center;
            width: 90%;
            max-width: 650px; /* 전체 게임 컨테이너 크기 증가 */
            margin-bottom: 20px; /* 푸터와의 간격 */
        }

        h1 {
            color: var(--o-color);
            font-size: 2.8rem; /* 제목 크기 증가 */
        }

        h2, h3 {
            color: var(--text-color);
            margin-bottom: 1.2rem;
            font-size: 1.8rem; /* 부제목 크기 증가 */
        }

        .hidden {
            display: none !important;
        }

        /* 게임 설정 */
        #game-setup {
            display: flex;
            flex-direction: column;
            gap: 1.8rem; /* 간격 증가 */
        }

        .mode-selection, .difficulty-selection {
            display: flex;
            justify-content: center;
            gap: 15px; /* 간격 증가 */
        }

        .mode-btn, .difficulty-btn {
            flex: 1;
            font-size: 1.1rem; /* 버튼 텍스트 크기 증가 */
        }

        .player-inputs {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 1.2rem;
        }

        input[type="text"] {
            padding: 12px; /* 입력 필드 패딩 증가 */
            border: 2px solid var(--board-bg);
            border-radius: 8px;
            font-size: 1.1rem; /* 입력 필드 텍스트 크기 증가 */
        }

        button {
            padding: 14px 25px; /* 버튼 패딩 증가 */
            font-size: 1.1rem;
            font-weight: bold;
            border: none;
            border-radius: 8px;
            background-color: var(--btn-bg);
            color: var(--text-color);
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        button:hover {
            background-color: var(--btn-hover-bg);
        }

        .active {
            background-color: var(--btn-active-bg) !important;
            color: white;
        }

        #start-game-btn {
            background-color: var(--x-color);
            color: white;
        }

        /* 게임 보드 */
        #status-display {
            font-size: 2rem; /* 상태 메시지 크기 증가 */
            margin-bottom: 1.5rem;
            font-weight: bold;
        }

        #game-board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 12px; /* 간격 증가 */
            width: 450px; /* 게임 보드 크기 증가 */
            height: 450px; /* 게임 보드 크기 증가 */
            margin: 0 auto;
            background-color: var(--board-bg);
            padding: 12px;
            border-radius: 10px;
        }

        .cell {
            background-color: var(--cell-bg);
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 6rem; /* 셀 안의 X/O 크기 증가 */
            font-weight: bold;
            cursor: pointer;
            user-select: none;
        }

        .cell.x { color: var(--x-color); }
        .cell.o { color: var(--o-color); }

        #reset-btn {
            margin-top: 1.8rem;
        }

        /* 게임 종료 모달 */
        #game-over-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background-color: white;
            padding: 2.5rem 3.5rem; /* 모달 패딩 증가 */
            border-radius: 15px;
            text-align: center;
        }

        #game-over-message {
            font-size: 2.2rem; /* 모달 메시지 크기 증가 */
            margin-bottom: 1.8rem;
        }

        /* 푸터 스타일 */
        footer {
            margin-top: 20px;
            color: #666;
            font-size: 0.9rem;
        }

        /* 반응형 디자인 */
        @media (max-width: 600px) { /* 더 작은 화면에 대한 미디어 쿼리 */
            .game-container {
                padding: 1.5rem;
                max-width: 95%; /* 작은 화면에서 더 넓게 */
            }
            h1 { font-size: 2.2rem; }
            h2, h3 { font-size: 1.5rem; }
            button { font-size: 1rem; padding: 10px 18px; }
            input[type="text"] { font-size: 1rem; padding: 10px; }
            #status-display { font-size: 1.8rem; }
            #game-board {
                width: 90vw; /* 뷰포트 너비의 90% */
                height: 90vw;
                max-width: 350px; /* 최대 크기 제한 */
                max-height: 350px;
                gap: 8px;
            }
            .cell {
                font-size: 12vw; /* 뷰포트 너비에 비례하여 셀 내용 크기 조정 */
                max-font-size: 5rem;
            }
            #game-over-message { font-size: 1.8rem; }
            footer { font-size: 0.8rem; }
        }
        /* CSS 코드 끝 */
    </style>
</head>
<body>
    <div class="game-container">
        <h1>틱택토 게임</h1>

        <div id="game-setup">
            <h2>게임 모드 선택</h2>
            <div class="mode-selection">
                <button id="pvc-btn" class="mode-btn active">컴퓨터와 대결</button>
                <button id="pvp-btn" class="mode-btn">친구와 대결</button>
            </div>

            <div id="pvc-options">
                <h3>난이도 선택</h3>
                <div class="difficulty-selection">
                    <button data-difficulty="easy" class="difficulty-btn active">초급</button>
                    <button data-difficulty="medium" class="difficulty-btn">중급</button>
                    <button data-difficulty="hard" class="difficulty-btn">고급</button>
                </div>
            </div>

            <div id="pvp-options" class="hidden">
                <h3>플레이어 이름 입력</h3>
                <div class="player-inputs">
                    <input type="text" id="player1-name" placeholder="플레이어 1 이름" value="Player 1">
                    <input type="text" id="player2-name" placeholder="플레이어 2 이름" value="Player 2">
                </div>
                <button id="first-move-btn">선공 랜덤 결정</button>
            </div>
            
            <button id="start-game-btn">게임 시작</button>
        </div>

        <div id="game-board-container" class="hidden">
            <div id="status-display">플레이어 X의 차례</div>
            <div id="game-board">
                <div class="cell" data-cell-index="0"></div>
                <div class="cell" data-cell-index="1"></div>
                <div class="cell" data-cell-index="2"></div>
                <div class="cell" data-cell-index="3"></div>
                <div class="cell" data-cell-index="4"></div>
                <div class="cell" data-cell-index="5"></div>
                <div class="cell" data-cell-index="6"></div>
                <div class="cell" data-cell-index="7"></div>
                <div class="cell" data-cell-index="8"></div>
            </div>
            <button id="reset-btn">처음으로</button>
        </div>

        <div id="game-over-modal" class="hidden">
            <div class="modal-content">
                <p id="game-over-message"></p>
                <button id="play-again-btn">다시하기</button>
            </div>
        </div>
    </div>
    
    <footer>
        만든이 by 깐깐샘
    </footer>

    <script>
        // JavaScript 코드 시작
        document.addEventListener('DOMContentLoaded', () => {
            // DOM 요소 가져오기
            const gameSetup = document.getElementById('game-setup');
            const pvcBtn = document.getElementById('pvc-btn');
            const pvpBtn = document.getElementById('pvp-btn');
            const pvcOptions = document.getElementById('pvc-options');
            const pvpOptions = document.getElementById('pvp-options');
            const difficultyBtns = document.querySelectorAll('.difficulty-btn');
            const firstMoveBtn = document.getElementById('first-move-btn');
            const startGameBtn = document.getElementById('start-game-btn');
            const gameBoardContainer = document.getElementById('game-board-container');
            const statusDisplay = document.getElementById('status-display');
            const cells = document.querySelectorAll('.cell');
            const resetBtn = document.getElementById('reset-btn');
            const gameOverModal = document.getElementById('game-over-modal');
            const gameOverMessage = document.getElementById('game-over-message');
            const playAgainBtn = document.getElementById('play-again-btn');
            const player1NameInput = document.getElementById('player1-name');
            const player2NameInput = document.getElementById('player2-name');

            // 게임 상태 변수
            let gameActive = false;
            let currentPlayer = 'X';
            let gameState = ["", "", "", "", "", "", "", "", ""];
            let gameMode = 'pvc'; // 'pvc' 또는 'pvp'
            let difficulty = 'easy'; // 'easy', 'medium', 'hard'
            let playerNames = { X: 'Player 1', O: 'Player 2' };

            const winningConditions = [
                [0, 1, 2], [3, 4, 5], [6, 7, 8], // 가로
                [0, 3, 6], [1, 4, 7], [2, 5, 8], // 세로
                [0, 4, 8], [2, 4, 6]             // 대각선
            ];

            // --- 이벤트 리스너 설정 ---

            // 게임 모드 선택
            pvcBtn.addEventListener('click', () => {
                gameMode = 'pvc';
                pvcBtn.classList.add('active');
                pvpBtn.classList.remove('active');
                pvcOptions.classList.remove('hidden');
                pvpOptions.classList.add('hidden');
            });

            pvpBtn.addEventListener('click', () => {
                gameMode = 'pvp';
                pvpBtn.classList.add('active');
                pvcBtn.classList.remove('active');
                pvpOptions.classList.remove('hidden');
                pvcOptions.classList.add('hidden');
            });
            
            // 난이도 선택
            difficultyBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    difficulty = btn.dataset.difficulty;
                    difficultyBtns.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                });
            });

            // 선공 결정
            firstMoveBtn.addEventListener('click', () => {
                const p1Name = player1NameInput.value.trim() || 'Player 1';
                const p2Name = player2NameInput.value.trim() || 'Player 2';
                if (Math.random() < 0.5) {
                    playerNames = { X: p1Name, O: p2Name };
                    alert(`${p1Name}(X)님이 선공입니다!`);
                } else {
                    playerNames = { X: p2Name, O: p1Name };
                    alert(`${p2Name}(X)님이 선공입니다!`);
                }
            });
            
            // 게임 시작
            startGameBtn.addEventListener('click', startGame);

            // 셀 클릭
            cells.forEach(cell => cell.addEventListener('click', handleCellClick));

            // 게임 리셋
            resetBtn.addEventListener('click', () => {
                gameBoardContainer.classList.add('hidden');
                gameSetup.classList.remove('hidden');
                gameOverModal.classList.add('hidden');
            });

            // 다시하기
            playAgainBtn.addEventListener('click', startGame);

            // --- 게임 로직 함수 ---

            function startGame() {
                gameActive = true;
                currentPlayer = 'X';
                gameState = ["", "", "", "", "", "", "", "", ""];
                
                // PvP 모드 이름 설정
                if (gameMode === 'pvp') {
                    const p1Name = player1NameInput.value.trim() || 'Player 1';
                    const p2Name = player2NameInput.value.trim() || 'Player 2';
                    // 선공 결정 버튼을 누르지 않았을 경우 기본값 설정
                    if (!playerNames.X || (playerNames.X !== p1Name && playerNames.X !== p2Name)) {
                        playerNames = { X: p1Name, O: p2Name };
                    }
                } else {
                    playerNames = { X: '당신', O: '컴퓨터' };
                }

                updateUI();
                gameSetup.classList.add('hidden');
                gameBoardContainer.classList.remove('hidden');
                gameOverModal.classList.add('hidden');
            }

            function handleCellClick(e) {
                const clickedCell = e.target;
                const clickedCellIndex = parseInt(clickedCell.getAttribute('data-cell-index'));

                if (gameState[clickedCellIndex] !== "" || !gameActive) {
                    return;
                }

                handleCellPlayed(clickedCell, clickedCellIndex);
                handleResultValidation();
            }

            function handleCellPlayed(cell, index) {
                gameState[index] = currentPlayer;
                cell.textContent = currentPlayer;
                cell.classList.add(currentPlayer.toLowerCase());
            }

            function handlePlayerChange() {
                currentPlayer = currentPlayer === "X" ? "O" : "X";
                updateStatusDisplay();
            }

            function handleResultValidation() {
                let roundWon = false;
                for (let i = 0; i < winningConditions.length; i++) {
                    const winCondition = winningConditions[i];
                    let a = gameState[winCondition[0]];
                    let b = gameState[winCondition[1]];
                    let c = gameState[winCondition[2]];
                    if (a === '' || b === '' || c === '') {
                        continue;
                    }
                    if (a === b && b === c) {
                        roundWon = true;
                        break;
                    }
                }

                if (roundWon) {
                    endGame(false);
                    return;
                }

                let roundDraw = !gameState.includes("");
                if (roundDraw) {
                    endGame(true);
                    return;
                }

                handlePlayerChange();
                
                // 컴퓨터 차례
                if (gameMode === 'pvc' && currentPlayer === 'O' && gameActive) {
                    // 컴퓨터가 생각하는 것처럼 보이게 딜레이 추가
                    setTimeout(computerMove, 500);
                }
            }

            function endGame(draw) {
                gameActive = false;
                if (draw) {
                    gameOverMessage.textContent = '무승부입니다!';
                } else {
                    gameOverMessage.textContent = `${playerNames[currentPlayer]}님의 승리!`;
                }
                gameOverModal.classList.remove('hidden');
            }

            function updateUI() {
                cells.forEach((cell, index) => {
                    cell.textContent = gameState[index];
                    cell.classList.remove('x', 'o');
                    if(gameState[index] === 'X') cell.classList.add('x');
                    if(gameState[index] === 'O') cell.classList.add('o');
                });
                updateStatusDisplay();
            }

            function updateStatusDisplay() {
                statusDisplay.textContent = `${playerNames[currentPlayer]}님의 차례`;
            }

            // --- 컴퓨터 AI 로직 ---

            function computerMove() {
                if (!gameActive) return;

                let move;
                // 난이도에 따라 다른 로직 실행
                const probability = Math.random();

                switch (difficulty) {
                    case 'easy': // 초급: 이길 수 있으면 이기고, 나머지는 50% 확률로 막거나 랜덤
                        move = findWinningMove('O');
                        if (move === null) {
                            if (probability < 0.5) { // 50% 확률로 방어
                                move = findWinningMove('X');
                            }
                            if (move === null) {
                                move = getRandomMove();
                            }
                        }
                        break;
                    
                    case 'medium': // 중급: 이길 수 있으면 이기고, 막을 수 있으면 막고, 나머지는 30% 확률로 랜덤
                        move = findWinningMove('O'); // 1. 내가 이기는 수
                        if (move === null) {
                            move = findWinningMove('X'); // 2. 상대가 이기는 수 막기
                        }
                        if (move !== null && probability < 0.3) { // 30% 확률로 최선의 수를 두지 않음
                            move = getRandomMove([move]); // 최선의 수를 제외하고 랜덤
                        }
                        if (move === null) {
                            move = getRandomMove(); // 3. 랜덤
                        }
                        break;

                    case 'hard': // 고급: 이길 수 있으면 이기고, 막을 수 있으면 막고, 10% 확률로만 랜덤
                        move = findWinningMove('O');
                        if (move === null) {
                            move = findWinningMove('X');
                        }
                        if (move !== null && probability < 0.1) { // 10% 확률로 실수
                            move = getRandomMove([move]);
                        }
                        if (move === null) {
                            // 중앙이 비었으면 차지
                            if(gameState[4] === "") {
                                move = 4;
                            } else {
                                // 그 외에는 비어있는 코너나 변을 차지
                                move = getStrategicMove();
                            }
                        }
                        break;
                }

                if (move !== null) {
                    const cell = document.querySelector(`.cell[data-cell-index='${move}']`);
                    handleCellPlayed(cell, move);
                    handleResultValidation();
                }
            }
            
            // 승리할 수 있는 위치나 막아야 할 위치를 찾는 함수
            function findWinningMove(player) {
                for (let i = 0; i < winningConditions.length; i++) {
                    const [a, b, c] = winningConditions[i];
                    if (gameState[a] === player && gameState[b] === player && gameState[c] === '') return c;
                    if (gameState[a] === player && gameState[c] === player && gameState[b] === '') return b;
                    if (gameState[b] === player && gameState[c] === player && gameState[a] === '') return a;
                }
                return null;
            }

            // 비어있는 셀 중 랜덤으로 선택하는 함수
            function getRandomMove(exclude = []) {
                let availableCells = [];
                for (let i = 0; i < gameState.length; i++) {
                    if (gameState[i] === '' && !exclude.includes(i)) {
                        availableCells.push(i);
                    }
                }
                if (availableCells.length > 0) {
                    return availableCells[Math.floor(Math.random() * availableCells.length)];
                }
                return null; // 모든 셀이 찼을 경우
            }
            
            // 고급 난이도를 위한 전략적 수
            function getStrategicMove() {
                // 1. 코너가 비었으면 코너 차지
                const corners = [0, 2, 6, 8];
                const availableCorners = corners.filter(i => gameState[i] === '');
                if(availableCorners.length > 0) {
                    return availableCorners[Math.floor(Math.random() * availableCorners.length)];
                }

                // 2. 코너가 다 찼으면 변 차지
                const sides = [1, 3, 5, 7];
                const availableSides = sides.filter(i => gameState[i] === '');
                if(availableSides.length > 0) {
                    return availableSides[Math.floor(Math.random() * availableSides.length)];
                }
                
                return getRandomMove(); // 만약 모두 실패하면 랜덤
            }

        });
        // JavaScript 코드 끝
    </script>
</body>
</html>
